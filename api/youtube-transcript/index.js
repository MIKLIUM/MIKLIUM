const { ApifyClient } = require('apify-client');

const client = new ApifyClient({
  token: process.env.APIFY_TOKEN,
});

async function handler(req, res) {
  try {
    let url, removeTimestamps, includeInfo;
    
    if (req.method === "GET") {
      url = req.query.url || "";
      removeTimestamps = req.query.removeTimestamps === 'true' || req.query.removeTimestamps === '1';
      includeInfo = req.query.includeInfo === 'true' || req.query.includeInfo === '1';
    } else if (req.method === "POST") {
      const body = req.body || {};
      url = body.url;
      removeTimestamps = body.removeTimestamps === true || body.removeTimestamps === 'true';
      includeInfo = body.includeInfo === true || body.includeInfo === 'true';
    } else {
      return res.status(405).json({ success: false, error: "Method not allowed" });
    }
    
    const videoId = extractVideoId(url);
    
    if (!videoId) {
      return res.status(400).json({ success: false, error: 'Invalid YouTube URL.' });
    }

    const result = await fetchVideo(videoId, { removeTimestamps, includeInfo });

    res.setHeader('Content-Type', 'application/json');
    res.status(200).json(result);
    
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: 'Internal server error'
    });
  }
};

async function fetchVideo(videoId, options) {
  const { removeTimestamps, includeInfo } = options;

  const apifyInput = {
    downloadSubtitles: true,
    hasCC: false,
    hasLocation: false,
    hasSubtitles: false,
    is360: false,
    is3D: false,
    is4K: false,
    isBought: false,
    isHD: false,
    isHDR: false,
    isLive: false,
    isVR180: false,
    maxResultStreams: 0,
    maxResults: 1,
    maxResultsShorts: 0,
    preferAutoGeneratedSubtitles: false,
    saveSubsToKVS: false,
    startUrls: [{ url: `https://youtu.be/${videoId}` }]
  };

  const run = await client.actor("h7sDV53CddomktSi5").call(apifyInput);
  const { items } = await client.dataset(run.defaultDatasetId).listItems();
  
  if (!items || items.length === 0) {
    return { success: false, error: 'Video not found or no data returned' };
  }

  return buildResponse(items[0], { removeTimestamps, includeInfo });
}

function buildResponse(data, options) {
  const { removeTimestamps, includeInfo } = options;
  
  const transcript = processSubtitles(data.subtitles, removeTimestamps);

  const response = {
    success: true,
    transcript
  };

  if (includeInfo) {
    response.info = {
      video: {
        id: data.id
        title: data.title,
        description: data.text,
        duration: data.duration,
        date: data.date,
        hashtags: data.hashtags
      },
      channel: {
        name: data.channelName,
        username: data.channelUsername,
        subscribers: data.numberOfSubscribers
      },
      stats: {
        views: data.viewCount,
        likes: data.likes,
        comments: data.commentsCount
      }
    };
  }

  return response;
}

function extractVideoId(url) {
  if (!url) return null;

  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=|shorts\/)([^#&?]*).*/;
  const match = url.match(regExp);
  
  if (match && match[2].length === 11) {
    return match[2];
  }
  
  if (url.length === 11 && /^[a-zA-Z0-9_-]+$/.test(url)) {
    return url;
  }
  
  return null;
}

function processSubtitles(subtitles, removeTimestamps) {
  if (!subtitles || subtitles.length === 0) {
    return null;
  }

  const subtitle = subtitles[0];
  
  if (!subtitle || !subtitle.srt) {
    return null;
  }

  return removeTimestamps ? cleanSRT(subtitle.srt) : subtitle.srt;
}

function cleanSRT(srtText) {
  if (!srtText) return '';
  
  const blocks = srtText.split(/\n\n+/);
  const textLines = [];
  
  for (const block of blocks) {
    const lines = block.trim().split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      if (!trimmed) continue;
      if (/^\d+$/.test(trimmed)) continue;
      if (/^\d{2}:\d{2}:\d{1,2},\d{1,3}\s*-->\s*\d{2}:\d{2}:\d{1,2},\d{1,3}$/.test(trimmed)) continue;
      
      textLines.push(trimmed);
    }
  }
  
  const unique = textLines.filter((line, i) => i === 0 || line !== textLines[i - 1]);
  
  return unique.join(' ').replace(/\s+/g, ' ').trim();
}

module.exports = handler;